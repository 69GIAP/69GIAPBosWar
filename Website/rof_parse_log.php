<?PHP
// rof_parse_log.php 
// a simple-minded parser/stats/events reporter for combined RoF
// mission report textfiles
// written by =69.GIAP=TUSHKA
// 2011-2013
// Version 69GIAPBoSWar 0.4
// Thu Sep 19 2013
//

// the main program 

//record the starting time
$start=microtime();
$start=explode(" ",$start);
$start=$start[1]+$start[0];

// Begin Configuration - Edit these as needed.

// Debugging variables
$DEBUG = 0;  // set to 1 for a complete debugging report, 0 for off.
// 100 for START, 101 for HIT, 102 for DAMAGE, 103 for KILL,
// 104 for PLAYER_MISSION_END, 105 for TAKEOFF, 106 for LANDING,
// 107 for MISSION_END, 108 for MISSION_OBJECTIVE, 109 for AIRFIELD,
// 110 for PLAYERPLANE, 111 for GROUPINIT, 112 for GAMEOBJECTINVOLVED
// 113 for INFLUENCEAREA_HEADER, 114 for INFLUENCEAREA_BOUNDARY,
// 115 for VERSION (nothing yet for BOTID... haven't found its use)


// Get Individual variables from the campaign's campaign_settings table
$query = "SELECT * FROM campaign_settings";
if(!$result = $camp_link->query($query))
   { die('There was an error running the query [' . $camp_link->error . ']'); }
	
if ($result = mysqli_query($camp_link, $query)) {
	 // get results
	 while ($obj = mysqli_fetch_object($result)) {
		$SHOWAF	=($obj->show_airfield);
		$FinishFlightOnlyLanded = ($obj->finish_flight_only_landed);
		$map_locations	=($obj->map_locations);
		$LOGPATH	=($obj->logpath);
		$LOGFILE	=($obj->logfile);
	}
        // free result set
	mysqli_free_result($result);
}
// debugging
print "DEBUGGING: rof_parse_log.php parser configuration:<br>\n";
print "SHOWAF = $SHOWAF<br>\n";
print "FinishFlightOnlyLanded = $FinishFlightOnlyLanded<br>\n";
print "map_locations = $map_locations<br>\n";
print "LOGPATH = $LOGPATH<br>\n";
print "LOGFILE = $LOGFILE<br>\n";

// Declare global variables.
// This permits us to see these in functions without using them as
// arguments to the functions.  Lazy but effective!
global $camp_link;  // link to campaign db
global $map_locations;  // name of campaign locations file

// Set path to logfile relative to parser
$LOGFILE = $LOGPATH."/".$LOGFILE;

// End individual variables

//End Configuration
// Don't edit anything below this line unless you know what you are doing.

// initialize counting variables to zero
$numstart = 0 ; // number of starts (hopefully just 1)
$numhits = 0 ; // total number of hits
$numdamage = 0; // total number of damage events
$numkills = 0 ; // total number of kills
$numends = 0; // total number of mission end events
$numtakeoffs = 0 ; // total number of takeoffs
$numlandings = 0 ; // total number of landings
$numplayers = 0 ; // total number of players
$numgobjects = 0; // total number of game objects involved
$numevents = 0; // total number of events
$numgroups = 0; // total number of groups
$numB = 0; // number of boundary definitions
$numiaheaders = 0; // number of influence area headers

// require core functions called by the main program
// READLOG
require ('rof_parser/functions/coreREADLOG.php');
// PARSE
require ('rof_parser/functions/corePARSE.php');
// PROCESS
require ('rof_parser/functions/corePROCESS.php');
// OUTPUT
require ('rof_parser/functions/coreOUTPUT.php');

// now get to work
if (file_exists("$LOGFILE")) {
   // the main program is simple - only four stages
   READLOG($LOGFILE); // read the logfile
   PARSE($numlines); // parse the logfile 
   PROCESS($numlines); // manipulate the data to extract the stats we want
   OUTPUT(); // display a mission report
} else {
   echo("Could not open $LOGFILE");
}
// done
// record the ending time
$end=microtime();
$end=explode(" ",$end);
$end=$end[1]+$end[0];
//printf("<p>Page was generated by PHP %s in %f seconds</p>\n",phpversion(),$end-$start); 
printf("<p>Report generated in %.1f seconds</p>\n",$end-$start); 

// Thus endeth the main program - the remainder is just functions and a borrowed class.
// Of course all the interesting stuff happens in the functions and the borrowed class.

// FUNCTIONS (in roughly the order they are used)
// Then the functions that OUTPUT calls
// and finally OUTPUT itself

// FUNCTIONS called by OUTPUT (in alphabetical order):
// ACCURACY, ANORA, CLOCKTIME, COUNTRYNAME, CRASHED, DEAD, FATES,
// FLYING, GUNNER, LOSSES, OBJECTCOUNTRYNAME, OBJECTNAME, OBJECTTYPE,
// PLAYERNAME, TOFROM, WHERE,  WHOSEGUNNER, XYZ

function OBJECTTYPE ($id,$ticks) {
// get object TYPE from ID
   global $Ticks; // time since start of mission in 1/50 sec ticks
   global $ID; // object ID
   global $TYPE; // type of object in this context
   global $objecttype; // object type from PID/AID/TID
   global $numgobjects; // number of game objects involved
   global $GOline; // lines defining game objects
   
   // T:36590 AType:12 ID:223250 TYPE:Albatros D.III COUNTRY:501 NAME:Plane PID:-1^M
   $objecttype = "";
   $found = "0";
   for ($i = 0; $i < $numgobjects; ++$i) {
      $j = $GOline[$i];
      if (("$ID[$j]" == "$id") && ($Ticks[$j] <= $ticks)) {
         $objecttype = $TYPE[$j];
         $found = "1";
      }
   }
   if ( $id == "-1") {
      $objecttype = "Intrinsic";
   } elseif (!$found) {
      $objecttype = "Uknown Object";
   }
}

function TOFROM($where) {
// massage $where string to show takeoff "from" rather than "at" or "next to"
   global $where; // position in english

   $where = preg_replace("/^at/", "from", $where);
   $where = preg_replace("/next to/", "from", $where);
}

function WHERE($x,$z,$fieldonly) {
// find closest location and vaguely describe distance from it
// if $fieldonly is 1 check airfields only
   global $camp_link;  // link to campaign db
   global $map_locations;  // name of campaign locations file
   global $Locs; // locations
   global $playername; // player name from PLID
   global $numlocs; // number of locations
   global $LID; // location ID
   global $LX; // location X coordinate
   global $LZ; // location Z coordinate
   global $LName; // location name
   global $where; // position in english
   global $SHOWAF; // Show airfield names (binary)

   // set starting conditions
   $mindist = 20001; // 20 km plus a meter
   $minname = "";
   $mintype = 0;
   $minfield = "";

//   $query = "SELECT * FROM '$map_locations'";
   $query = "SELECT * FROM $map_locations";
   // if no result report error  (could do this as an 'else' clause also)
   if(!$result = $camp_link->query($query)) {
      die('There was an error running the query [' . $camp_link->error . ']');
   }

// find closest location using brute force... only 660/743 locations to check.  :)
 // Tried to see if restricting calculations to a certain square helped any.
 // It didn't :)
   if ($fieldonly) {
      if ($result = mysqli_query($camp_link, $query)) {
         while ($obj = mysqli_fetch_object($result)) {
            $LID=($obj->LID);
            $LX	=($obj->LX);
            $LZ	=($obj->LZ);
            $LName =($obj->LName);

	    // check airfields only
            if (( $LID == "10" ) || ( $LID == "20" )) {
	       // check if this location is closer
               $distance = sqrt(pow($x -$LX,2) + pow($z - $LZ,2));
               if ( $mindist > $distance) {
                  $mintype = $LID;
                  $mindist = $distance;
                  $minname = $LName;
//                 echo "$mindist from $LName<br>\n";
	       }
	    }
         }
      }
   } else {
      if ($result = mysqli_query($camp_link, $query)) {
         while ($obj = mysqli_fetch_object($result)) {
            $LID=($obj->LID);
            $LX	=($obj->LX);
            $LZ	=($obj->LZ);
            $LName =($obj->LName);

	    // check if this location is closer
            $distance = sqrt(pow($x -$LX,2) + pow($z - $LZ,2));
            if ( $mindist > $distance) {
               $mintype = $LID;
               $mindist = $distance;
               $minname = $LName;
//               echo "$mindist from $LName<br>\n";
	    }
         }
      }
   }
   // free result set
   mysqli_free_result($result);

   //echo "$mindist from $minname<br>\n";
   // translate distances into appropriate but vague modifiers
   if ($mindist < 750) { $desc = "at"; }
   elseif ($mindist < 1500.0) { $desc = "next to"; }
   elseif ($mindist < 2500.0) { $desc = "near"; }
   elseif ($mindist < 5000.0) { $desc = "within sight of"; }
   elseif ($mindist < 10000.0) { $desc = "a good way from"; }
   elseif ($mindist < 20000.0) { $desc = "far from"; }
   else { $desc = "in the middle of nowhere"; }
   // if small airfield or regular airfield add airfield to location name
   if ( $mindist >= 20000.0 ) {
     $where = $desc;
   } elseif (( $mintype == "10" ) || ( $mintype == "20" )) {
     if ($SHOWAF) { 
       $where = $desc . " " . $minname . " airfield";
     } else {
       $where = $desc . " " . "an undisclosed airfield";
     }
   } else {
     $where = $desc . " " . $minname;
   }
//   echo "$desc<br>";
}

function WHOSEGUNNER($id) {
// no longer used?
// given gunner id, find player name
   global $ID; // object ID
   global $PID; // plane ID (whether bot or player)
   global $PLID; // player plane id 
   global $NAME; // player profile name
   global $numgobjects; // number of game objects involved
   global $GOline; // lines defining game objects
   global $numplayers; // number of players
   global $Pline;  // lines that define players
   global $Whosegunner; // player piloting this gunner
   
   $pid = 0;
   $Whosegunner = "";
   for ($i = 0; $i < $numgobjects; ++$i) {
      $j = $GOline[$i];
      if ($id == $ID[$j]) {
         $pid = $PID[$j];
         for ($k = 0; $k < $numplayers; ++$k) {
            $l = $Pline[$k];
            if ($pid == $PLID[$l]) {
               $Whosegunner = "$NAME[$l]'s";
            }
         } 
      }
   }
   if ($Whosegunner == "")
      {
         $Whosegunner = "an unpiloted plane's AI";
      }
//  echo "WHOSEGUNNER: ID=$id, PID = $pid whosegunner = $Whosegunner<br>\n";
}

function XYZ($POS) {
// Break POS into X, Y and Z.
   global $posx; // X coordinate
   global $posy; // Y coordinate (altitude)
   global $posz; // Z coordinate

   // remove slashes and spaces
   $POS = preg_replace("/\(/","",$POS);
   $POS = preg_replace("/\)/","",$POS);
   $POS = preg_replace("/ /","",$POS);
   $Part = explode(",",$POS,3); // split into X, Y and Z at ","
   $posx = trim($Part[0]);
   $posy = trim($Part[1]);
   $posz = trim($Part[2]);
}
// end of FUNCTIONS called by OUTPUT

?>
